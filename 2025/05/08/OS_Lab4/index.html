<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OS-Lab4 | 小熊猫为了春日半岛写代码</title><meta name="author" content="Nice2cu"><meta name="copyright" content="Nice2cu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="#OS-Lab4 OS_Lab4感觉lab4和lab3都比lab2好一些，笨人以为五一玩脱了之后根本来不及学了，，，没想到看着竟然还行。。。可能这就是受lab2和lab3摧残之后的结果吧，这篇文章记录一下学习lab4的心路历程。其实更重要的是想自己写一遍加深一下印象！ 从实验目的开始：  掌握系统调用的概念及流程 实现进程间通信机制 实现 fork 函数 掌握页写入异常的处理流程  1.系统调用1">
<meta property="og:type" content="article">
<meta property="og:title" content="OS-Lab4">
<meta property="og:url" content="http://nice2cu22.github.io/2025/05/08/OS_Lab4/index.html">
<meta property="og:site_name" content="小熊猫为了春日半岛写代码">
<meta property="og:description" content="#OS-Lab4 OS_Lab4感觉lab4和lab3都比lab2好一些，笨人以为五一玩脱了之后根本来不及学了，，，没想到看着竟然还行。。。可能这就是受lab2和lab3摧残之后的结果吧，这篇文章记录一下学习lab4的心路历程。其实更重要的是想自己写一遍加深一下印象！ 从实验目的开始：  掌握系统调用的概念及流程 实现进程间通信机制 实现 fork 函数 掌握页写入异常的处理流程  1.系统调用1">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://nice2cu22.github.io/img/top-default.jpg">
<meta property="article:published_time" content="2025-05-08T02:29:00.000Z">
<meta property="article:modified_time" content="2025-05-08T02:29:11.538Z">
<meta property="article:author" content="Nice2cu">
<meta property="article:tag" content="BUAA_OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nice2cu22.github.io/img/top-default.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OS-Lab4",
  "url": "http://nice2cu22.github.io/2025/05/08/OS_Lab4/",
  "image": "http://nice2cu22.github.io/img/top-default.jpg",
  "datePublished": "2025-05-08T02:29:00.000Z",
  "dateModified": "2025-05-08T02:29:11.538Z",
  "author": [
    {
      "@type": "Person",
      "name": "Nice2cu",
      "url": "http://nice2cu22.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://nice2cu22.github.io/2025/05/08/OS_Lab4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS-Lab4',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/my-avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-book-open"></i><span> 余光记</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-leaf"></i><span> 咒语图鉴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 词语盒</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-address-book"></i><span> 友人帐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/top-default.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小熊猫为了春日半岛写代码</span></a><a class="nav-page-title" href="/"><span class="site-name">OS-Lab4</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-book-open"></i><span> 余光记</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-leaf"></i><span> 咒语图鉴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 词语盒</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-address-book"></i><span> 友人帐</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">OS-Lab4</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-05-08T02:29:00.000Z" title="Created 2025-05-08 10:29:00">2025-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-05-08T02:29:11.538Z" title="Updated 2025-05-08 10:29:11">2025-05-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>#OS-Lab4</p>
<h1 id="OS-Lab4"><a href="#OS-Lab4" class="headerlink" title="OS_Lab4"></a>OS_Lab4</h1><p>感觉lab4和lab3都比lab2好一些，笨人以为五一玩脱了之后根本来不及学了，，，没想到看着竟然还行。。。可能这就是受lab2和lab3摧残之后的结果吧，这篇文章记录一下学习lab4的心路历程。其实更重要的是想自己写一遍加深一下印象！</p>
<p>从实验目的开始：</p>
<ol>
<li>掌握系统调用的概念及流程</li>
<li>实现进程间通信机制</li>
<li>实现 fork 函数</li>
<li>掌握页写入异常的处理流程</li>
</ol>
<h3 id="1-系统调用"><a href="#1-系统调用" class="headerlink" title="1.系统调用"></a>1.系统调用</h3><h4 id="1-1-用户态与内核态"><a href="#1-1-用户态与内核态" class="headerlink" title="1.1 用户态与内核态"></a>1.1 用户态与内核态</h4><blockquote>
<p>用户进程在特定场景下需要执行只能由内核完成的操作（如硬件操作、动态分配内存、与其他进程进行通信）。由于在内核态执行用户程序的代码不安全，因此操作系统设计了一系列内核空间中的函数，当用户进行需要操作时，会引发特定的异常陷入内核态，由内核调用对应的函数。这种机制叫做<strong>系统调用</strong></p>
</blockquote>
<p><strong>用户进程&amp;内核</strong>：进程是资源分配与调度的基本单位，拥有独立的地址空间。内核负责管理系统资源和调度进程，使得进程能够并发执行。二者并不是对立的存在，可认为内核时存在于所有地址空间中的一段代码。</p>
<p>人话版：<strong>每个进程的地址空间被划分成两部分：用户态和内核态</strong>。</p>
<h4 id="1-2-系统调用实例"><a href="#1-2-系统调用实例" class="headerlink" title="1.2 系统调用实例"></a>1.2 系统调用实例</h4><ul>
<li>用户调用 puts 函数</li>
<li>在一系列的函数调用后，最终调用了 write 函数</li>
<li>write 函数在寄存器中设置了对应的系统调用号以及相应的参数，并执行了 syscall 指令</li>
<li>进入内核态，内核中相应的函数或服务被执行</li>
<li>回到用户态的 write 函数中，将结果从相关的寄存器中取回，并返回</li>
<li>再次经过一系列的返回过程后，回到了 puts 函数中</li>
<li>puts 函数返回</li>
</ul>
<h4 id="1-3-系统调用机制的实现"><a href="#1-3-系统调用机制的实现" class="headerlink" title="1.3 系统调用机制的实现"></a>1.3 系统调用机制的实现</h4><blockquote>
<p>debugf 函数内部的逻辑可分为两部分，一部分负责将参数解析为字符串，一部分负责将字符串输出（debug_output 函数）</p>
<p>debug_output 函数调用了用户空间的 syscall_* _函数</p>
<p><em>syscall</em>* 函数调用了 msyscall 函数，系统由此陷入内核态</p>
<p>内核态中将异常分发到 handle_sys 函数，将系统调用所需要的信息 (在此处是需要输出的字符串 s) 传递入内核</p>
<p>内核取得信息，执行对应的内核空间的系统调用函数（sys_*）</p>
<p>系统调用完成，并返回用户态，同时将返回值“传递”回用户态</p>
<p>从系统调用函数返回，回到用户程序 debugf 调用处</p>
</blockquote>
<p><strong>🐾 举个栗子：</strong></p>
<p>假设我写了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugf(&quot;第五人格启动\n&quot;);</span><br></pre></td></tr></table></figure>

<p>幕后其实是这样执行的：</p>
<ol>
<li><code>debugf()</code> 把格式化字符串 <code>&quot;第五人格启动\n&quot;</code> 传给 <code>debug_output()</code>；</li>
<li><code>debug_output()</code> 调用 <code>syscall_write(s)</code>（或其他 <code>syscall_*()</code>）；</li>
<li><code>syscall_write()</code> 把字符串放到寄存器或内存里，调用 <code>msyscall()</code>；</li>
<li><code>msyscall()</code> 执行一个软中断 <code>int $T_SYSCALL</code>，进入内核态；</li>
<li>内核的 <code>handle_sys()</code> 收到中断，看出这是写操作；</li>
<li>跳转到 <code>sys_write()</code>，执行真正的“输出”；</li>
<li>写完后返回用户态，把返回值交给 <code>debugf()</code>；</li>
</ol>
<p><em><em>用户态 → syscall_* → msyscall → handle_sys → sys_</em> → 返回结果</em>*</p>
<p>接下来我们学习<strong>系统调用号</strong>：</p>
<p>在我们的 MOS 操作系统实验中，这些 syscall_* 的函数与内核中的系统调用函数（sys_*的函数）是一一对应的。</p>
<ul>
<li>syscall_* 的函数是我们在用户空间中最接近的内核的函数，在用户态调用。</li>
<li>sys_* 的函数是内核中系统调用的具体实现部分，在内核态执行。</li>
</ul>
<p>在所有 syscall_* 的函数的实现中，都调用了 msyscall 函数。</p>
<p>msyscall 函数的第一个参数是一个与调用名相似的宏。例：SYS_print_cons 。这个参数就是系统调用号</p>
<p><strong>作用</strong>：系统调用号是内核区分不同系统调用的唯一依据</p>
<p><strong>msyscall 函数的参数</strong>：</p>
<p>msyscall 一共有 6 个参数，除系统调用号之外 msyscall 函数还有 5 个参数，这些参数是系统调用时需要传递给内核的参数。</p>
<ul>
<li>前 4 个参数会被 syscall_* 的函数分别存入 $a0-$a3 寄存器（寄存器传参的部分）同时栈帧底部保留 16 字节的空间（不要求存入参数的值）。</li>
<li>后 2 个参数只会被存入在预留空间之上的 8 字节空间内（没有寄存器传参）。</li>
<li>总共 24 字节的空间用于参数传递。</li>
</ul>
<p><strong>Exercise 4.1：</strong></p>
<p>填写 user&#x2F;lib&#x2F;syscall_wrap.S 中的 msyscall 函数。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">syscall</span></span><br><span class="line"><span class="symbol">jr</span> ra</span><br></pre></td></tr></table></figure>

<p>当系统调用发生时，操作系统首先跳转到 <code>handle_sys()</code>（这个入口在汇编 <code>genex.S</code> 里），然后它会调用 C 写的 <code>do_syscall()</code> 去完成实际的系统调用处理工作。</p>
<h5 id="🖼️-打个比喻帮你记住："><a href="#🖼️-打个比喻帮你记住：" class="headerlink" title="🖼️ 打个比喻帮你记住："></a>🖼️ 打个比喻帮你记住：</h5><table>
<thead>
<tr>
<th>角色</th>
<th>名字</th>
<th>比喻</th>
</tr>
</thead>
<tbody><tr>
<td><code>msyscall()</code></td>
<td>用户态触发点</td>
<td>你在窗口按铃“我要服务！”</td>
</tr>
<tr>
<td><code>handle_sys()</code></td>
<td>汇编包装函数</td>
<td>接待员来接你，领你进去</td>
</tr>
<tr>
<td><code>do_syscall()</code></td>
<td>C 写的业务逻辑</td>
<td>专家开始处理你的请求，比如打印、打开文件</td>
</tr>
</tbody></table>
<p><strong>Exercise 4.2：</strong></p>
<p>完成do_syscall函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">if</span> (sysno &lt; <span class="number">0</span> || sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Exercise 4.2: Your code here. (1/4) */</span></span><br><span class="line">    <span class="comment">//系统调用执行完后，要回到用户程序的下一条指令，所以把 PC（程序计数器）+4。</span></span><br><span class="line">	tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Exercise 4.2: Your code here. (2/4) */</span></span><br><span class="line">    <span class="comment">//从系统调用表 syscall_table[] 中，根据编号 sysno 找到对应的处理函数</span></span><br><span class="line">	func = syscall_table[sysno];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出第 2~4 个参数，分别来自寄存器 $a1 ~ $a3（也就是 regs[5] ~ regs[7]）</span></span><br><span class="line">	u_int arg1 = tf-&gt;regs[<span class="number">5</span>];</span><br><span class="line">	u_int arg2 = tf-&gt;regs[<span class="number">6</span>];</span><br><span class="line">	u_int arg3 = tf-&gt;regs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	u_int arg4, arg5;</span><br><span class="line">	<span class="comment">/* Exercise 4.2: Your code here. (3/4) */</span></span><br><span class="line">    <span class="comment">//第 5 和第 6 个参数是放在用户栈上的。regs[29] 是 $sp（用户栈顶），栈上参数是从 $sp + 16 和 $sp + 20 开始的，所以加 4、加 5 就是偏移了 16 和 20 字节</span></span><br><span class="line">	arg4 = *((u_int *)tf-&gt;regs[<span class="number">29</span>] + <span class="number">4</span>);</span><br><span class="line">	arg5 = *((u_int *)tf-&gt;regs[<span class="number">29</span>] + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Exercise 4.2: Your code here. (4/4) */</span></span><br><span class="line">    <span class="comment">//最后，调用 func(...)，将其返回值写入 $v0（regs[2]），这个值会回传给用户程序。</span></span><br><span class="line">	tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完这一步，整个系统调用的机制已经可以正常工作，接下来我们来实现几个具体的系统调用！</p>
<h4 id="1-4-基础系统调用函数"><a href="#1-4-基础系统调用函数" class="headerlink" title="1.4 基础系统调用函数"></a><strong>1.4 基础系统调用函数</strong></h4><p><strong>Exercise 4.3</strong>:</p>
<p> 实现 kern&#x2F;env.c 中的 envid2env 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">envid2env</span><span class="params">(u_int envid, <span class="keyword">struct</span> Env **penv, <span class="type">int</span> checkperm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">//如果你传进来的 envid 是 0，就默认是当前进程（curenv），所以直接返回当前进程就好了</span></span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">		*penv = curenv;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ENVX 是一个宏，提取出 envid 的低位作为下标，查找 envs[] 这个数组。</span></span><br><span class="line">	e = &amp;envs[ENVX(envid)];</span><br><span class="line">	<span class="comment">//检查这个 Env 合不合法</span></span><br><span class="line">	<span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果需要检查权限，并且这个进程既不是当前进程自己，也不是你的孩子，那就报错。</span></span><br><span class="line">	<span class="keyword">if</span> (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//把找到的 Env * 放到 *penv 里面，表示成功。</span></span><br><span class="line">	*penv = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Exercise 4.4</strong> :</p>
<p>实现 kern&#x2F;syscall_all.c 中的 int sys_mem_alloc(u_int envid,u_int va, u_int perm) 函数。</p>
<blockquote>
<p><code>sys_mem_alloc(envid, va, perm)</code> 是一个系统调用，帮某个用户进程在指定的虚拟地址 <code>va</code> 分配一页物理内存，并建立映射（并设置访问权限 <code>perm</code>）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="comment">//Step 1: 检查虚拟地址是否合法</span></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//Step 2: 把 envid 转成 struct Env*</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//Step 3: 分配一页物理内存</span></span><br><span class="line">	try(page_alloc(&amp;pp));</span><br><span class="line">    <span class="comment">//Step 4: 建立页表映射</span></span><br><span class="line">	<span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, pp, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Exercise 4.5</strong> :</p>
<p>实现 <code>kern/syscall_all.c</code> 中的 <code>int sys_mem_map(u_int srcid,u_int srcva, u_int dstid, u_int dstva, u_int perm)</code> 函数。</p>
<p><code>sys_mem_map</code> 函数的作用，就是： <strong>把一个进程的某块内存，映射（共享）到另一个进程去。</strong></p>
<blockquote>
<p>就像把小疯归宿里的一把小椅子🪑，搬到了小小疯家里，<br> 两个人都可以坐，而且其实是同一把椅子！！✨</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">dstenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="comment">//检查源地址 srcva 和目标地址 dstva 有没有超出合法的用户地址空间。</span></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va(srcva) || is_illegal_va(dstva)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//把源 srcid 和目标 dstid 这两个进程的ID，转换成struct Env * 类型指针🏡！这时候会顺便检查权限</span></span><br><span class="line">	try(envid2env(srcid, &amp;srcenv, <span class="number">1</span>));</span><br><span class="line">	try(envid2env(dstid, &amp;dstenv, <span class="number">1</span>));</span><br><span class="line">	<span class="comment">//srcva 这个虚拟地址，映射到哪一块物理内存（Page *pp）。</span></span><br><span class="line">	pp = page_lookup(srcenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">//建立页表映射</span></span><br><span class="line">	<span class="keyword">return</span> page_insert(dstenv-&gt;env_pgdir, dstenv-&gt;env_asid, pp, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Exercise 4.6</strong> ：</p>
<p>实现 <code>kern/syscall_all.c</code> 中的 <code>int sys_mem_unmap(u_int envid, u_intva)</code> 函数。</p>
<p>一句话总结一下：<strong>取消内存映射！把一块虚拟地址对应的物理内存解绑掉</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nt <span class="title function_">sys_mem_unmap</span><span class="params">(u_int envid, u_int va)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	try(envid2env(envid, &amp;e, <span class="number">1</span>));</span><br><span class="line">	page_remove(e-&gt;env_pgdir, e-&gt;env_asid, va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Exercise 4.7</strong> ：</p>
<p>实现 kern&#x2F;syscall_all.c 中的 void sys_yield(void) 函数。</p>
<p>这个函数的功能是<strong>实现用户进程对 CPU 的放弃，从而调度其他的进程。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) sys_yield(<span class="type">void</span>) &#123;</span><br><span class="line">	schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>schedule(1)</code>：自己主动想休息，叫“自愿让出 CPU”。</p>
<p><code>schedule(0)</code>：被动被系统安排换人，比如时间到了、出错了之类的。</p>
<h3 id="2-进程间通信机制-IPC-："><a href="#2-进程间通信机制-IPC-：" class="headerlink" title="2.进程间通信机制(IPC)："></a>2.进程间通信机制(IPC)：</h3><p>进程间通信机制 (IPC) 是微内核最重要的机制之一。</p>
<blockquote>
<p>我们知道，所有的进程都共享同一个内核空间（主要为 kseg0）。因此，想要在不同空间之间交换数据，我们就可以借助于内核空间来实现。发送方进程可以将数据以系统调用的形式存放在进程控制块中，接收方进程同样以系统调用的方式在进程控制块中找到对应的数据，读取并返回。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span> </span><br><span class="line">	u_int env_ipc_value; <span class="comment">//进程传递的具体数值</span></span><br><span class="line">	u_int env_ipc_from; <span class="comment">//发送方的进程 ID</span></span><br><span class="line">	u_int env_ipc_recving; <span class="comment">//1：等待接受数据中；0：不可接受数据</span></span><br><span class="line">	u_int env_ipc_dstva; <span class="comment">//接收到的页面需要与自身的哪个虚拟页面完成映射</span></span><br><span class="line">	u_int env_ipc_perm; <span class="comment">//传递的页面的权限位设置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Exercise 4.8</strong>：</p>
<p> 实现 <code>kern/syscall_all.c</code> 中的 <code>int sys_ipc_recv(u_int dstva)</code> 函数和<code>int sys_ipc_try_send(u_int envid, u_int value, u_int srcva, u_int perm)</code> 函数。请注意在修改进程控制块的状态后，应同步维护调度队列。</p>
<p><code>int sys_ipc_recv(u_int dstva)</code><strong>的目的是：让当前进程（curenv）进入“接收消息”的状态，并让出CPU，等着别的进程给它发消息。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_recv</span><span class="params">(u_int dstva)</span> &#123;</span><br><span class="line">    <span class="comment">//检查目标虚拟地址 dstva 是否合法。</span></span><br><span class="line">	<span class="keyword">if</span> (dstva != <span class="number">0</span> &amp;&amp; is_illegal_va(dstva)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//记当前进程正在等待接收消息。</span></span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//记录好用户想接收数据的地址。</span></span><br><span class="line">	curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    <span class="comment">//把当前进程设置为“不可运行”状态，并从调度链表中移除。</span></span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	TAILQ_REMOVE(&amp;env_sched_list, curenv, env_sched_link);</span><br><span class="line">    <span class="comment">//最后，主动让出CPU，切换到其他进程运行。regs[2] 是 $v0 寄存器（返回值位置），这里先写个0。</span></span><br><span class="line">	((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>)-&gt;regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>int sys_ipc_recv(u_int dstva)</code><strong>的目的是把当前进程（发送者）想要发送的内容，交给目标进程（接收者）。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_send</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">//检查 srcva（发送的内存地址）是否合法。只要不是 0，就必须是合法的用户态地址</span></span><br><span class="line">	<span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va(srcva)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//找到目标进程 e</span></span><br><span class="line">	try(envid2env(envid, &amp;e, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//确认目标进程现在正“等着接收”！</span></span><br><span class="line">	<span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//填充接收者的 IPC 相关字段。</span></span><br><span class="line">	e-&gt;env_ipc_value = value;</span><br><span class="line">	e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	e-&gt;env_ipc_perm = PTE_V | perm;</span><br><span class="line">	e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//把接收者重新设成可运行（RUNNABLE），放回调度队列。</span></span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">    <span class="comment">//如果有页面需要传递，做页面映射！</span></span><br><span class="line">	<span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">		p = page_lookup(curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是，由于在我们的用户程序中，会大量使用 srcva 为 0 的调用来表示只传value 值，而不需要传递物理页面。</p>
<h3 id="3-Fork"><a href="#3-Fork" class="headerlink" title="3.Fork"></a>3.Fork</h3><h4 id="3-1-初窥fork"><a href="#3-1-初窥fork" class="headerlink" title="3.1 初窥fork"></a>3.1 初窥fork</h4><blockquote>
<p>在 Lab3 我们曾提到过，内核通过 env_create 函数创建一个进程。但如果要让一个进程创建一个进程，我们就需要基于系统调用，引入新的 fork 机制了。</p>
</blockquote>
<ul>
<li>fork 之前只有父进程存在。</li>
<li>fork 之后，父子进程同时开始执行 fork 之后的代码段。</li>
<li>fork 在不同的进程中返回值不一样，在子进程中返回值为 0，在父进程中返回值不为 0，而为子进程的 pid（Linux 中进程专属的 id，类似于 MOS 中的 envid）。</li>
<li>父进程和子进程虽然很多信息相同，但他们的进程控制块是不同的。</li>
</ul>
<blockquote>
<p>我们简要概括一下整个 fork 实现过程中可能需要阅读或实现的文件，包括：</p>
</blockquote>
<p>（这段感觉指导书说的不是人话，我自己写一下）</p>
<h5 id="1-内核部分（kern-目录）"><a href="#1-内核部分（kern-目录）" class="headerlink" title="1. 内核部分（kern/目录）"></a>1. 内核部分（<code>kern/</code>目录）</h5><hr>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>kern/syscall_all.c</code></strong></td>
<td>实现一些系统调用，支持进程创建、状态切换、TLB异常等</td>
</tr>
<tr>
<td>→ <code>sys_exofork</code></td>
<td>创建一个子进程，但还没执行内容（像<code>fork()</code>一样，拷贝父进程状态）</td>
</tr>
<tr>
<td>→ <code>sys_set_env_status</code></td>
<td>修改进程状态，比如让子进程可以运行（RUNNABLE）</td>
</tr>
<tr>
<td>→ <code>sys_set_tlb_mod_entry</code></td>
<td>写时复制 (COW) 相关的 TLB 修改异常处理设定</td>
</tr>
<tr>
<td><strong><code>kern/tlbex.c</code></strong></td>
<td>TLB异常处理，尤其是写时复制 (COW) 的时候要做一些设置</td>
</tr>
<tr>
<td>→ <code>do_tlb_mod</code></td>
<td>处理因为写时复制触发的TLB修改异常，比如给页面换上真正可写的权限</td>
</tr>
</tbody></table>
<hr>
<h5 id="2-用户态部分（user-lib-目录）"><a href="#2-用户态部分（user-lib-目录）" class="headerlink" title="2. 用户态部分（user/lib/目录）"></a>2. 用户态部分（<code>user/lib/</code>目录）</h5><hr>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>user/lib/fork.c</code></strong></td>
<td>重点！用户态实现 <code>fork</code>，包括页表拷贝、处理COW页面等</td>
</tr>
<tr>
<td>→ <code>fork</code></td>
<td>最主要的fork逻辑，包括调用系统调用、拷贝地址空间等</td>
</tr>
<tr>
<td>→ <code>duppage</code></td>
<td>把父进程的某一页拷贝到子进程，如果要共享要做成 COW</td>
</tr>
<tr>
<td>→ <code>cow_entry</code></td>
<td>处理COW异常，真正发生写的时候，给自己分配一个新的可写页</td>
</tr>
<tr>
<td><strong><code>user/lib/entry.S</code></strong></td>
<td>程序入口，设置好堆栈等，跳到 C 语言入口函数（比如 <code>main</code>）</td>
</tr>
<tr>
<td><strong><code>user/lib/libos.c</code></strong></td>
<td>包含程序开始和退出的一些准备，比如调用 <code>main()</code></td>
</tr>
</tbody></table>
<hr>
<h5 id="3-其他重要参考文件"><a href="#3-其他重要参考文件" class="headerlink" title="3. 其他重要参考文件"></a>3. 其他重要参考文件</h5><hr>
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>kern/genex.S</code></strong></td>
<td>汇编实现异常入口（Exception Entry），CPU发生异常时的第一步</td>
</tr>
<tr>
<td></td>
<td>比如发生缺页异常、系统调用异常，就会跳到这里</td>
</tr>
<tr>
<td></td>
<td>建议了解，尤其是<strong>异常流程（trap-&gt;中断-&gt;回到用户态）</strong></td>
</tr>
</tbody></table>
<h4 id="3-2-写时复制机制"><a href="#3-2-写时复制机制" class="headerlink" title="3.2 写时复制机制"></a>3.2 写时复制机制</h4><ol>
<li><strong>fork的时候</strong>，父子进程<strong>共享同一块物理内存</strong>，<strong>不拷贝！</strong></li>
<li>系统只是<strong>把共享的页面加上“COW标记”</strong>，让这块内存变成了<strong>“谁先写谁复制”</strong>。</li>
<li><strong>如果父子都只是读数据</strong>，那就一直共用一块物理页，啥都不用复制，超级省内存！</li>
<li><strong>只有真的发生写入</strong>的时候，系统才：<ul>
<li>给写的人<strong>分配一块新的物理内存</strong>，</li>
<li>把旧数据复制一份过去，</li>
<li>然后继续执行写操作。</li>
</ul>
</li>
</ol>
<h5 id="写时复制机制的实现："><a href="#写时复制机制的实现：" class="headerlink" title="写时复制机制的实现："></a>写时复制机制的实现：</h5><p><strong>🛠 1. 靠“异常”触发。</strong></p>
<p>于是我们可以故意在 fork 时，把<strong>本来可以写的页面，暂时标记成”只读”（取消PTE_D）</strong>。</p>
<p><strong>📖 2. 触发异常以后，怎么办？</strong></p>
<ul>
<li>给当前进程<strong>分配一块新的物理内存页</strong>。</li>
<li><strong>把原来那页的内容复制到新页</strong>里。</li>
<li>然后把这块<strong>新的物理页映射到当前进程的虚拟地址上</strong>。</li>
</ul>
<p>🆚 <strong>3. 怎么分辨是真正的只读，还是写时复制？</strong></p>
<p>于是我们在 TLB 页表项里加了一个<strong>PTE_COW（Copy-on-Write）</strong>的小标志</p>
<h4 id="3-3-fork的返回值"><a href="#3-3-fork的返回值" class="headerlink" title="3.3  fork的返回值"></a>3.3  fork的返回值</h4><p><strong>Exercise 4.9</strong> ：</p>
<p>填写 <code>kern/syscall_all.c</code> 中的<code>sys_exofork</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">//分配新进程</span></span><br><span class="line">	try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">//拷贝当前进程的 Trapframe（CPU 现场）</span></span><br><span class="line">	e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//修改子进程 Trapframe 中的返回值 $v0</span></span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置子进程状态 + 继承父亲的优先级</span></span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="comment">//最后，返回子进程的 envid</span></span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-地址空间的准备"><a href="#3-4-地址空间的准备" class="headerlink" title="3.4 地址空间的准备"></a>3.4 地址空间的准备</h4><blockquote>
<p>因此在子进程第一次被调度的时候（当然这时还是在 fork 函数中）需要对 env 指针进行更新，使其仍指向当前进程的控制块。此外，父进程还需要将地址空间中需要与子进程共享的页面映射给子进程，这需要我们遍历父进程的大部分用户空间页，并使用将要实现的 duppage 函数来完成这一过程。duppage 时，对于可以写入的页面的页表项，在父进程和子进程都需要加上 PTE_COW 标志位，同时取消 <strong>PTE_D</strong>标志位，以实现写时复制保护。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">duppage</span><span class="params">(u_int envid, u_int vpn)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int addr;</span><br><span class="line">	u_int perm;</span><br><span class="line">    <span class="comment">//先拿到地址和权限位</span></span><br><span class="line">	addr = vpn &lt;&lt; PGSHIFT;</span><br><span class="line">	perm = vpt[vpn] &amp; ((<span class="number">1</span> &lt;&lt; PGSHIFT) - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果满足下面三种情况之一，说明直接普通映射就行：</span></span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; PTE_D) == <span class="number">0</span> || (perm &amp; PTE_LIBRARY) || (perm &amp; PTE_COW)) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)addr, envid, (<span class="type">void</span> *)addr, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;user panic mem map error: %d&quot;</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//先把页面拷贝到子进程，取消写权限 (~PTE_D) 并加上 PTE_COW。</span></span><br><span class="line">		<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)addr, envid, (<span class="type">void</span> *)addr,(perm &amp; ~PTE_D) | PTE_COW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;user panic mem map error: %d&quot;</span>, r);</span><br><span class="line">		&#125;<span class="comment">//再把父进程自己的映射也改成 COW。</span></span><br><span class="line">		<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)addr, <span class="number">0</span>, (<span class="type">void</span> *)addr,(perm &amp; ~PTE_D) | PTE_COW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;user panic mem map error: %d&quot;</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-页写入异常"><a href="#3-5-页写入异常" class="headerlink" title="3.5 页写入异常"></a>3.5 页写入异常</h4><blockquote>
<p>我们在异常向量组中为其注册了一个处理函数 handle_mod，这一函数会跳转到 kern&#x2F;tlbex.c中的 do_tlb_mod 函数中，这个函数正是处理页写入异常的内核函数。</p>
</blockquote>
<h5 id="✅do-tlb-mod-做了什么？"><a href="#✅do-tlb-mod-做了什么？" class="headerlink" title="✅do_tlb_mod 做了什么？"></a>✅<strong>do_tlb_mod 做了什么？</strong></h5><p>你可能以为它会直接在内核里复制页面（做写时复制），但它没这么做！因为：</p>
<blockquote>
<p>MOS 是个“微内核”风格的系统，很多功能都放到<strong>用户空间来处理</strong></p>
</blockquote>
<p>所以它的做法是：</p>
<ul>
<li><strong>保存当前进程的状态（Trapframe）</strong>，用来之后恢复</li>
<li>设置参数（a0 寄存器）和 EPC（程序下一步执行的地址）</li>
<li>跳转到用户程序自己定义的异常处理函数，也就是你自己写的 <code>cow_entry</code></li>
</ul>
<p>这样异常的后续处理就在用户空间完成了～</p>
<p>✅<strong>然后 <code>cow_entry</code> 会：</strong></p>
<ul>
<li>找到是哪个页面写出了问题</li>
<li>给它<strong>真正复制一份新页面</strong></li>
<li>把写权限设置好</li>
<li>再通过 <code>syscall_set_trapframe</code> 把程序原来的运行状态恢复，让它继续跑下去！</li>
</ul>
<p><strong>Exercise 4.11</strong> ：</p>
<p>根据上述提示以及代码注释，完成 <code>kern/tlbex.c</code> 中的 <code>do_tlb_mod</code> 函数，设置好保存的现场中 EPC 寄存器的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_tlb_mod</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="comment">//复制一份当前的 Trapframe（寄存器快照、程序状态等），备份现场，后面要用来传给用户态处理函数。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line">	<span class="comment">//如果现在还在正常用户栈（即 $sp 在正常用户空间里），就把它换成异常处理栈的栈顶（UXSTACKTOP）</span></span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把刚才复制的 tmp_tf 压到新的栈上（异常处理栈）：</span></span><br><span class="line">	tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">	*(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查一下哪个页出错了：</span></span><br><span class="line">	Pte *pte;</span><br><span class="line">	page_lookup(cur_pgdir, tf-&gt;cp0_badvaddr, &amp;pte);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查当前进程有没有注册自己的异常处理函数。</span></span><br><span class="line">	<span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;</span><br><span class="line">        <span class="comment">//把 $sp 的当前值（也就是异常处理栈顶）传给 $a0（寄存器4）</span></span><br><span class="line">		tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];</span><br><span class="line">        <span class="comment">//把刚才 $a0 的参数也压到栈上</span></span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);</span><br><span class="line">    <span class="comment">//设置异常返回地址</span></span><br><span class="line">	tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>syscall_exofork</code> 之前，我们需要使用 <code>syscall_set_tlb_mod_entry</code>函数来注册自身的页写入异常处理函数</p>
<p><strong>Exercise 4.12</strong> ：</p>
<p>完成 kern&#x2F;syscall_all.c 中的 sys_set_tlb_mod_entry 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_tlb_mod_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">	env-&gt;env_user_tlb_mod_entry = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在知道了页写入异常处理时会返回到用户空间的 <code>cow_entry</code> 函数，我们再来看这个函数会做些什么。</p>
<p><strong>Exercise 4.13</strong> ：</p>
<p>填写 user&#x2F;lib&#x2F;fork.c 中的 cow_entry 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) cow_entry(<span class="keyword">struct</span> Trapframe *tf) &#123;</span><br><span class="line">	u_int va = tf-&gt;cp0_badvaddr;</span><br><span class="line">	u_int perm;</span><br><span class="line">	perm = PTE_FLAGS(vpt[VPN(va)]);</span><br><span class="line">    <span class="comment">//找到触发异常的虚拟地址 va 的权限</span></span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; PTE_COW) == <span class="number">0</span>) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;PTE_COW not found, va=%08x, perm=%08x&quot;</span>, va, perm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//修改权限</span></span><br><span class="line">	perm = (perm &amp; ~PTE_COW) | PTE_D;</span><br><span class="line">    <span class="comment">//分配一页新的物理页</span></span><br><span class="line">	syscall_mem_alloc(<span class="number">0</span>, (<span class="type">void</span> *)UCOW, perm);</span><br><span class="line">    <span class="comment">//复制原页面内容</span></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">void</span> *)UCOW, (<span class="type">void</span> *)ROUNDDOWN(va, PAGE_SIZE), PAGE_SIZE);</span><br><span class="line">    <span class="comment">//用新页替换旧页</span></span><br><span class="line">	syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)UCOW, <span class="number">0</span>, (<span class="type">void</span> *)va, perm);</span><br><span class="line">    <span class="comment">//清理临时映射</span></span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)UCOW);</span><br><span class="line">    <span class="comment">//回到原程序执行现场</span></span><br><span class="line">	<span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">	user_panic(<span class="string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，父进程通过系统调用 syscall_set_env_status 设置子进程为可以运行的状态。</p>
<p><strong>Exercise 4.14</strong> ：</p>
<p>填写 kern&#x2F;syscall_all.c 中的 sys_set_env_status 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_env_status</span><span class="params">(u_int envid, u_int status)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="comment">//检查传入的状态是否合法,status 只能是这两种之一</span></span><br><span class="line">	<span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//根据新状态修改调度队列</span></span><br><span class="line">	<span class="keyword">if</span> (status == ENV_RUNNABLE &amp;&amp; env-&gt;env_status != ENV_RUNNABLE) &#123;</span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == ENV_NOT_RUNNABLE &amp;&amp; env-&gt;env_status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">		TAILQ_REMOVE(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//设置它的新状态</span></span><br><span class="line">	env-&gt;env_status = status;</span><br><span class="line">    <span class="comment">//如果你改的是当前运行的进程，就主动触发调度</span></span><br><span class="line">	<span class="keyword">if</span> (env == curenv) &#123;</span><br><span class="line">		schedule(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到这里我们需要整理一下思路，fork 中父进程在 syscall_exofork 后还需要做的事情有：</p>
<ol>
<li>遍历父进程地址空间，进行 duppage。</li>
<li>设置子进程的异常处理函数，确保页写入异常可以被正常处理。</li>
<li>设置子进程的 env_status，允许其被调度。</li>
</ol>
<p>最后再将子进程的 envid 返回，fork 函数就完成了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u_int child;</span><br><span class="line">	u_int i;</span><br><span class="line">    <span class="comment">//设置 TLB Mod 异常处理函数为 cow_entry</span></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry) &#123;</span><br><span class="line">		try(syscall_set_tlb_mod_entry(<span class="number">0</span>, cow_entry));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过 syscall_exofork() 创建子进程</span></span><br><span class="line">	child = syscall_exofork();</span><br><span class="line">	<span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">		env = envs + ENVX(syscall_getenvid());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//将用户栈以下的页复制（共享）到子进程，使用 duppage()</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDX(UXSTACKTOP); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vpd[i] &amp; PTE_V) &#123;</span><br><span class="line">			<span class="keyword">for</span> (u_int j = <span class="number">0</span>; j &lt; PAGE_SIZE / <span class="keyword">sizeof</span>(Pte); j++) &#123;</span><br><span class="line">				u_long va = (i * (PAGE_SIZE / <span class="keyword">sizeof</span>(Pte)) + j) &lt;&lt; PGSHIFT;</span><br><span class="line">				<span class="keyword">if</span> (va &gt;= USTACKTOP) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (vpt[VPN(va)] &amp; PTE_V) &#123;</span><br><span class="line">					duppage(child, VPN(va));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为子进程设置 TLB Mod 处理函数，并把它设为可运行</span></span><br><span class="line">	syscall_set_tlb_mod_entry(child, cow_entry);</span><br><span class="line">	syscall_set_env_status(child, ENV_RUNNABLE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下fork部分：</p>
<p><code>fork（）</code>函数中除了<code>syscall_exofork()</code>;创建了一个子进程，其他做的都是为页写入异常的准备工作（<code>duppage</code>、<code>syscall_set_tlb_mod_entry</code>、<code>syscall_set_env_status</code>）</p>
<p>当子进程or父进程想要写数据时，MIPS 会陷入页写入异常（TLB Mod）。</p>
<pre><code>          用户进程写 COW 页
                 ↓
     ⛔ CPU 触发 TLB Mod 异常（页不可写）
                 ↓
  MIPS 硬件跳转到异常入口地址（异常向量）
                 ↓
    🔧 genex.S：汇编保存现场 + 跳转
                 ↓
    注册的 handler_mod 被调用（异常号分发）
                     ↓
   🧠 handle_mod() 中调用 do_tlb_mod()
                     ↓
 do_tlb_mod() 处理 TLB Mod 异常，准备好用户态异常处理栈，并跳转到 cow_entry()
                     ↓
     用户态执行 cow_entry()（开始写时复制）
</code></pre>
<p>收回笨人的话，，，难难难！！@！！！@！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://Nice2cu22.github.io">Nice2cu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://nice2cu22.github.io/2025/05/08/OS_Lab4/">http://nice2cu22.github.io/2025/05/08/OS_Lab4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA-OS/">BUAA_OS</a></div><div class="post-share"><div class="social-share" data-image="/img/top-default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/22/OS-Lab3/" title="OS-Lab3"><img class="cover" src="/img/top-default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">OS-Lab3</div></div><div class="info-2"><div class="info-item-1">#OS-Lab3 OS_Lab3感觉lab3看着没有lab2那么晦涩难懂，可能是写lab2的时候完全搞不懂内存管理的机制，搞不懂内核地址和用户地址这些（而且你又不看ppt）。然后这篇文章就简单记录一下学习lab3的心路历程。 首先还是从lab3的实验目的开始：  创建一个进程并成功运行 实现时钟中断，通过时钟中断内核可以再次获得执行权 实现进程调度，创建两个进程，并且通过时钟中断切换进程执行   在Lab3中将运行一个用户模式的进程：使用数据结构进程控制块Env来跟踪用户进程，并建立一个简单的用户进程，再加载一个程序镜像到指定的内存空间，让他运行起来。  虽然这段话感觉有很多词都不明白，我们来依次解释一下：  用户模式： 🧠 用户模式是 CPU 的一种“低权限运行状态”，操作系统中有两种模式：    模式 特点    🧍‍♂️ 用户模式 限制权限，只能访问用户空间，不能执行特权指令   🧠 内核模式 全部权限，能执行系统指令、操作硬件   例如user/hello.c、user/fault.c 这些 ELF...</div></div></div></a><a class="pagination-related" href="/2025/05/27/OS_Lab5/" title="OS-Lab5"><img class="cover" src="/img/top-default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">OS-Lab5</div></div><div class="info-2"><div class="info-item-1">#OS-Lab5 OS_Lab5感觉lab5主要就是介绍了一个文件系统，用来抽象地管理磁盘等外设。目前感觉比较困难的地方应该是很多相似地函数跨越了多个系统层级，不是很分得清楚，，，但是是最后一次上机了，还是总结一下😋 实验目的：  了解文件系统的基本概念和作用。 了解普通磁盘的基本结构和读写方式。 了解实现设备驱动的方法。 掌握并实现文件系统服务的基本操作。 了解微内核的基本设计思想和结构。  1.文件系统概述1.1文件系统的设计与实现 📕文件系统：（为了便于管理和访问存放在外部存储设备上的数据）在文件系统中，文件是数据存储和访问的基本单位。   外部存储设备驱动：通过系统调用的方式陷入内核，对磁盘镜像进行读写操作。 文件系统结构：fs 目录下存放的是文件系统服务程序的代码；而 user/lib 目录中的 file.c、fd.c、fsipc.c 等文件则存放了文件系统的用户库。文件系统服务进程和其他用户进程之间使用 IPC机制进行通信 文件系统的用户接口：通过一个用户态的文件系统服务来实现   整体代码框架：   tools...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/22/OS-Lab3/" title="OS-Lab3"><img class="cover" src="/img/top-default.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-22</div><div class="info-item-2">OS-Lab3</div></div><div class="info-2"><div class="info-item-1">#OS-Lab3 OS_Lab3感觉lab3看着没有lab2那么晦涩难懂，可能是写lab2的时候完全搞不懂内存管理的机制，搞不懂内核地址和用户地址这些（而且你又不看ppt）。然后这篇文章就简单记录一下学习lab3的心路历程。 首先还是从lab3的实验目的开始：  创建一个进程并成功运行 实现时钟中断，通过时钟中断内核可以再次获得执行权 实现进程调度，创建两个进程，并且通过时钟中断切换进程执行   在Lab3中将运行一个用户模式的进程：使用数据结构进程控制块Env来跟踪用户进程，并建立一个简单的用户进程，再加载一个程序镜像到指定的内存空间，让他运行起来。  虽然这段话感觉有很多词都不明白，我们来依次解释一下：  用户模式： 🧠 用户模式是 CPU 的一种“低权限运行状态”，操作系统中有两种模式：    模式 特点    🧍‍♂️ 用户模式 限制权限，只能访问用户空间，不能执行特权指令   🧠 内核模式 全部权限，能执行系统指令、操作硬件   例如user/hello.c、user/fault.c 这些 ELF...</div></div></div></a><a class="pagination-related" href="/2025/05/27/OS_Lab5/" title="OS-Lab5"><img class="cover" src="/img/top-default.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-27</div><div class="info-item-2">OS-Lab5</div></div><div class="info-2"><div class="info-item-1">#OS-Lab5 OS_Lab5感觉lab5主要就是介绍了一个文件系统，用来抽象地管理磁盘等外设。目前感觉比较困难的地方应该是很多相似地函数跨越了多个系统层级，不是很分得清楚，，，但是是最后一次上机了，还是总结一下😋 实验目的：  了解文件系统的基本概念和作用。 了解普通磁盘的基本结构和读写方式。 了解实现设备驱动的方法。 掌握并实现文件系统服务的基本操作。 了解微内核的基本设计思想和结构。  1.文件系统概述1.1文件系统的设计与实现 📕文件系统：（为了便于管理和访问存放在外部存储设备上的数据）在文件系统中，文件是数据存储和访问的基本单位。   外部存储设备驱动：通过系统调用的方式陷入内核，对磁盘镜像进行读写操作。 文件系统结构：fs 目录下存放的是文件系统服务程序的代码；而 user/lib 目录中的 file.c、fd.c、fsipc.c 等文件则存放了文件系统的用户库。文件系统服务进程和其他用户进程之间使用 IPC机制进行通信 文件系统的用户接口：通过一个用户态的文件系统服务来实现   整体代码框架：   tools...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/my-avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Nice2cu</div><div class="author-info-description">ENFP快乐疯狗经典款</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content"><p>🚀 欢迎登录知识异次元空间！🔮</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#OS-Lab4"><span class="toc-number">1.</span> <span class="toc-text">OS_Lab4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%8E%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">1.1 用户态与内核态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">1.2 系统调用实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">1.3 系统调用机制的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%96%BC%EF%B8%8F-%E6%89%93%E4%B8%AA%E6%AF%94%E5%96%BB%E5%B8%AE%E4%BD%A0%E8%AE%B0%E4%BD%8F%EF%BC%9A"><span class="toc-number">1.0.1.3.1.</span> <span class="toc-text">🖼️ 打个比喻帮你记住：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">1.4 基础系统调用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6-IPC-%EF%BC%9A"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.进程间通信机制(IPC)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Fork"><span class="toc-number">1.0.3.</span> <span class="toc-text">3.Fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%88%9D%E7%AA%A5fork"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">3.1 初窥fork</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%85%E6%A0%B8%E9%83%A8%E5%88%86%EF%BC%88kern-%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-number">1.0.3.1.1.</span> <span class="toc-text">1. 内核部分（kern&#x2F;目录）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%94%A8%E6%88%B7%E6%80%81%E9%83%A8%E5%88%86%EF%BC%88user-lib-%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-number">1.0.3.1.2.</span> <span class="toc-text">2. 用户态部分（user&#x2F;lib&#x2F;目录）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E5%8F%82%E8%80%83%E6%96%87%E4%BB%B6"><span class="toc-number">1.0.3.1.3.</span> <span class="toc-text">3. 其他重要参考文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">3.2 写时复制机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.0.3.2.1.</span> <span class="toc-text">写时复制机制的实现：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-fork%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">3.3  fork的返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E5%87%86%E5%A4%87"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">3.4 地址空间的准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E9%A1%B5%E5%86%99%E5%85%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">3.5 页写入异常</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%9C%85do-tlb-mod-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.3.5.1.</span> <span class="toc-text">✅do_tlb_mod 做了什么？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/27/OS_Lab5/" title="OS-Lab5"><img src="/img/top-default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS-Lab5"/></a><div class="content"><a class="title" href="/2025/05/27/OS_Lab5/" title="OS-Lab5">OS-Lab5</a><time datetime="2025-05-27T15:01:31.000Z" title="Created 2025-05-27 23:01:31">2025-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/08/OS_Lab4/" title="OS-Lab4"><img src="/img/top-default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS-Lab4"/></a><div class="content"><a class="title" href="/2025/05/08/OS_Lab4/" title="OS-Lab4">OS-Lab4</a><time datetime="2025-05-08T02:29:00.000Z" title="Created 2025-05-08 10:29:00">2025-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/22/OS-Lab3/" title="OS-Lab3"><img src="/img/top-default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OS-Lab3"/></a><div class="content"><a class="title" href="/2025/04/22/OS-Lab3/" title="OS-Lab3">OS-Lab3</a><time datetime="2025-04-22T12:14:31.000Z" title="Created 2025-04-22 20:14:31">2025-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/13/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/" title="代码演示"><img src="/img/top-banner.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码演示"/></a><div class="content"><a class="title" href="/2025/04/13/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/" title="代码演示">代码演示</a><time datetime="2025-04-13T06:34:00.000Z" title="Created 2025-04-13 14:34:00">2025-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/12/hello-world/" title="Hello World"><img src="/img/top-default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2025/04/12/hello-world/" title="Hello World">Hello World</a><time datetime="2025-04-12T13:16:34.061Z" title="Created 2025-04-12 21:16:34">2025-04-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By Nice2cu</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>